[
  {
    "objectID": "homework8.html",
    "href": "homework8.html",
    "title": "Homework 8",
    "section": "",
    "text": "The goal of this data report is to perform exploratory data analysis (EDA), clean and transform the data, summarize it at a daily level, and then fit multiple linear regression (MLR) models with various complexities that simulate industry modeling.\nBefore we begin, lets import the required packages.\n\nsuppressPackageStartupMessages({\n  library(tidyverse)\n  library(readr)\n  library(httr)\n  library(lubridate)\n  library(dplyr)\n  library(janitor)\n  library(stringi)\n})\n\nWarning: package 'tidyverse' was built under R version 4.2.3\n\n\nWarning: package 'ggplot2' was built under R version 4.2.3\n\n\nWarning: package 'tidyr' was built under R version 4.2.3\n\n\nWarning: package 'readr' was built under R version 4.2.3\n\n\nWarning: package 'stringr' was built under R version 4.2.3\n\n\nWarning: package 'forcats' was built under R version 4.2.3\n\n\nWarning: package 'lubridate' was built under R version 4.2.3\n\nset.seed(42)\n\nWe begin by loading the Seoul Bike Sharing dataset directly from the NC State Statistics repository. We then want to ensure proper encoding to handle special characters (that typically come during data transfers and cloud sessions) andwhile also preventing data corruption. Column names are cleaned for consistency, and the Date variable is converted into a true date format using the lubricate function.\nFinally, categorical variables such as Seasons, Holiday, and Functioning Day are converted into factors, preparing the data for analysis and modeling, and also demonstrating a transformation that could commonly occurs."
  },
  {
    "objectID": "homework8.html#introduction",
    "href": "homework8.html#introduction",
    "title": "Homework 8",
    "section": "",
    "text": "The goal of this data report is to perform exploratory data analysis (EDA), clean and transform the data, summarize it at a daily level, and then fit multiple linear regression (MLR) models with various complexities that simulate industry modeling.\nBefore we begin, lets import the required packages.\n\nsuppressPackageStartupMessages({\n  library(tidyverse)\n  library(readr)\n  library(httr)\n  library(lubridate)\n  library(dplyr)\n  library(janitor)\n  library(stringi)\n})\n\nWarning: package 'tidyverse' was built under R version 4.2.3\n\n\nWarning: package 'ggplot2' was built under R version 4.2.3\n\n\nWarning: package 'tidyr' was built under R version 4.2.3\n\n\nWarning: package 'readr' was built under R version 4.2.3\n\n\nWarning: package 'stringr' was built under R version 4.2.3\n\n\nWarning: package 'forcats' was built under R version 4.2.3\n\n\nWarning: package 'lubridate' was built under R version 4.2.3\n\nset.seed(42)\n\nWe begin by loading the Seoul Bike Sharing dataset directly from the NC State Statistics repository. We then want to ensure proper encoding to handle special characters (that typically come during data transfers and cloud sessions) andwhile also preventing data corruption. Column names are cleaned for consistency, and the Date variable is converted into a true date format using the lubricate function.\nFinally, categorical variables such as Seasons, Holiday, and Functioning Day are converted into factors, preparing the data for analysis and modeling, and also demonstrating a transformation that could commonly occurs."
  },
  {
    "objectID": "homework8.html#analysis",
    "href": "homework8.html#analysis",
    "title": "Homework 8",
    "section": "Analysis",
    "text": "Analysis\n\nread_csv_utf8_normalized &lt;- function(url) {\n  #get resp and raw bytes from source\n  resp &lt;- httr::GET(url)\n  stop_for_status(resp)\n  raw &lt;- httr::content(resp, as = \"raw\")\n  \n  #take a guess on the encoding, using latin or utf-8 but it can be different\n  enc_guess &lt;- tryCatch(\n    readr::guess_encoding(raw)$encoding[1],\n    error = function(e) NULL\n  )\n  if (is.na(enc_guess) || is.null(enc_guess)) enc_guess &lt;- \"UTF-8\"\n  \n  #parse bytes and data using guessed encoding to see if we can read in\n  df &lt;- readr::read_csv(I(raw), locale = readr::locale(encoding = enc_guess), show_col_types = FALSE)\n  \n  #let's normalize char cols to UTF-8 ignoring the additional bytes\n  df &lt;- df %&gt;%\n    mutate(across(where(is.character), ~ stringi::stri_enc_toutf8(., is_unknown_8bit = TRUE)))\n  df\n}\n\ndata_url &lt;- \"https://www4.stat.ncsu.edu/~online/datasets/SeoulBikeData.csv\"\nbikes_raw &lt;- read_csv_utf8_normalized(data_url)\n\nNext, we want to clean column names and ensure correct data types so we can use the data downstream with the model. This is one of the more important processes for modeling, as an incorrect column name or data type can complete render the model code useless, until the data is adjusted.\n\n#normalize text encoding across char cols to convert to utf8 encoding\nbikes_raw &lt;- bikes_raw %&gt;%\n  dplyr::mutate(across(where(is.character),\n                       ~ iconv(., from = \"\", to = \"UTF-8\", sub = \"\")))\n\nNow we want to check for missing values and ensure that columns contain the expected data types that we want.\n\n#need to call data set and clean prior as well, to ensure out summarizations work\nbikes &lt;- bikes_raw %&gt;%\n  janitor::clean_names() %&gt;%\n  mutate(\n    date = lubridate::dmy(date),\n    seasons = as.factor(seasons),\n    holiday = as.factor(holiday),\n    functioning_day = as.factor(functioning_day)\n  )\n\nbikes %&gt;%\nsummarize(across(everything(), ~ sum(is.na(.)))) %&gt;%\npivot_longer(everything(), names_to = \"column\", values_to = \"n_missing\") %&gt;%\narrange(desc(n_missing))\n\n# A tibble: 14 × 2\n   column                  n_missing\n   &lt;chr&gt;                       &lt;int&gt;\n 1 date                            0\n 2 rented_bike_count               0\n 3 hour                            0\n 4 temperature_c                   0\n 5 humidity_percent                0\n 6 wind_speed_m_s                  0\n 7 visibility_10m                  0\n 8 dew_point_temperature_c         0\n 9 solar_radiation_mj_m2           0\n10 rainfall_mm                     0\n11 snowfall_cm                     0\n12 seasons                         0\n13 holiday                         0\n14 functioning_day                 0\n\n\nWe then need to filter out rows where bikes were not functioning (non-operational days).\n\nbikes_fun &lt;- bikes %&gt;%\nfilter(functioning_day == \"Yes\")\n\nif (nrow(bikes_fun) == 0) {\nbikes_fun &lt;- bikes\n}\n\nTo simplify the analysis, we want summarize the data to a daily level by season and holiday to reduce complexity and see if there are seasonal or holiday effects.\n\nWe sum bike counts and precipitation variables, and average weather conditions.\n\nnum_cols &lt;- bikes_fun %&gt;% select(where(is.numeric)) %&gt;% names()\nsum_cols &lt;- intersect(c(\"rented_bike_count\", \"rainfall_mm\", \"snowfall_cm\"), num_cols)\navg_cols &lt;- setdiff(num_cols, c(sum_cols, \"hour\"))\n\nbikes_daily &lt;- bikes_fun %&gt;%\ngroup_by(date, seasons, holiday) %&gt;%\nsummarize(\nacross(all_of(sum_cols), ~ sum(.x, na.rm = TRUE)),\nacross(all_of(avg_cols), ~ mean(.x, na.rm = TRUE)),\n.groups = \"drop\"\n) %&gt;%\nclean_names()\n\nWe calculate summary statistics across all numeric columns and categorical groups.\n\nbikes_daily %&gt;%\nsummarize(across(where(is.numeric), list(mean = mean, sd = sd, min = min, max = max), na.rm = TRUE))\n\n# A tibble: 1 × 36\n  rented_bike_count_mean rented_bike_count_sd rented_bike_count_min\n                   &lt;dbl&gt;                &lt;dbl&gt;                 &lt;dbl&gt;\n1                 17485.                9937.                   977\n# ℹ 33 more variables: rented_bike_count_max &lt;dbl&gt;, rainfall_mm_mean &lt;dbl&gt;,\n#   rainfall_mm_sd &lt;dbl&gt;, rainfall_mm_min &lt;dbl&gt;, rainfall_mm_max &lt;dbl&gt;,\n#   snowfall_cm_mean &lt;dbl&gt;, snowfall_cm_sd &lt;dbl&gt;, snowfall_cm_min &lt;dbl&gt;,\n#   snowfall_cm_max &lt;dbl&gt;, temperature_c_mean &lt;dbl&gt;, temperature_c_sd &lt;dbl&gt;,\n#   temperature_c_min &lt;dbl&gt;, temperature_c_max &lt;dbl&gt;,\n#   humidity_percent_mean &lt;dbl&gt;, humidity_percent_sd &lt;dbl&gt;,\n#   humidity_percent_min &lt;dbl&gt;, humidity_percent_max &lt;dbl&gt;, …\n\n\nWe can also compare daily rentals across seasons and holidays:\n\nbikes_daily %&gt;%\ngroup_by(seasons, holiday) %&gt;%\nsummarize(\ndays = n(),\navg_bikes = mean(rented_bike_count, na.rm = TRUE),\nsd_bikes = sd(rented_bike_count, na.rm = TRUE),\n.groups = \"drop\"\n)\n\n# A tibble: 8 × 5\n  seasons holiday     days avg_bikes sd_bikes\n  &lt;fct&gt;   &lt;fct&gt;      &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Autumn  Holiday        4    22754.    5642.\n2 Autumn  No Holiday    77    22065.    6792.\n3 Spring  Holiday        3    15247.   10917.\n4 Spring  No Holiday    87    18002.    8322.\n5 Summer  Holiday        2    24532.    8438.\n6 Summer  No Holiday    90    24824.    7324.\n7 Winter  Holiday        8     3759     1561.\n8 Winter  No Holiday    82     5574.    1757.\n\n\nWe then want to visualize key patterns across seasons and temperature.\n\n#return a boxplot of rentals by season\nggplot(bikes_daily, aes(seasons, rented_bike_count)) +\ngeom_boxplot(fill = \"orange\") +\nlabs(title = \"Daily Bike Rentals (Season)\", x = \"season\", y = \"rented bike count\")\n\n\n\n\n\n\n\n#scatter and trend on rentals v. temp\nggplot(bikes_daily, aes(temperature_c, rented_bike_count)) +\ngeom_point(alpha = 0.5) +\ngeom_smooth(method = \"lm\", se = FALSE) +\nlabs(title = \"Daily Rentals vs Temperature\", x = \"temperature (°C)\", y = \"rented bike count\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nWe create a weekday/weekend factor from the date variable.\n\nfeat_df &lt;- bikes_daily %&gt;%\nmutate(\nwday = wday(date, label = TRUE),\nday_type = factor(if_else(wday %in% c(\"Sat\", \"Sun\"), \"weekend\", \"weekday\"))\n) %&gt;%\nselect(-wday)"
  },
  {
    "objectID": "homework8.html#splitting-data",
    "href": "homework8.html#splitting-data",
    "title": "Homework 8",
    "section": "Splitting Data",
    "text": "Splitting Data\nWe perform a 75/25 train-test split, stratified by the seasons.\n\nstrat_split &lt;- function(df, prop = 0.75, strata_col = \"seasons\") {\ndf &lt;- df %&gt;% mutate(.rowid = row_number())\nidx_train &lt;- df %&gt;%\ngroup_by(.data[[strata_col]]) %&gt;%\ngroup_map(~ sample(.x$.rowid, size = ceiling(nrow(.x) * prop))) %&gt;%\nunlist()\nlist(\ntrain = df %&gt;% filter(.rowid %in% idx_train) %&gt;% select(-.rowid),\ntest = df %&gt;% filter(!(.rowid %in% idx_train)) %&gt;% select(-.rowid)\n)\n}\n\nspl &lt;- strat_split(feat_df, prop = 0.75, strata_col = \"seasons\")\ntrain_df &lt;- spl$train\ntest_df &lt;- spl$test"
  },
  {
    "objectID": "homework8.html#model-building-and-examples",
    "href": "homework8.html#model-building-and-examples",
    "title": "Homework 8",
    "section": "Model Building and Examples",
    "text": "Model Building and Examples\nWe define formulas for three regressions:\n\nModel 1: Base additive effects\nModel 2: Adds interactions\nModel 3: Adds quadratic terms\n\n\nbase_predictors &lt;- c(\n  \"seasons\", \"holiday\", \"day_type\",\n  \"temperature_c\", \"humidity\", \"windspeed_ms\", \"visibility_10m\",\n  \"dew_point_temperature_c\", \"solar_radiation_mj_m2\",\n  \"rainfall_mm\", \"snowfall_cm\"\n)\n\npresent_preds &lt;- intersect(base_predictors, names(train_df))\n\n#first form additive effects\nstopifnot(\"rented_bike_count\" %in% names(train_df))\nform1 &lt;- as.formula(paste(\n  \"rented_bike_count ~\",\n  if (length(present_preds)) paste(present_preds, collapse = \" + \") else \"1\"\n))\n\n#second form interactions\nint_terms &lt;- character(0)\nif (all(c(\"seasons\", \"holiday\") %in% names(train_df))) {\n  int_terms &lt;- c(int_terms, \"seasons:holiday\")\n}\nif (all(c(\"seasons\", \"temperature_c\") %in% names(train_df))) {\n  int_terms &lt;- c(int_terms, \"seasons:temperature_c\")\n}\nif (all(c(\"temperature_c\", \"rainfall_mm\") %in% names(train_df))) {\n  int_terms &lt;- c(int_terms, \"temperature_c:rainfall_mm\")\n}\n\nform2 &lt;- as.formula(paste(\n  \"rented_bike_count ~\",\n  paste(c(present_preds, int_terms), collapse = \" + \")\n))\n\n#third form quadratic\nnum_candidates &lt;- c(\n  \"temperature_c\",\"humidity\",\"windspeed_ms\",\"visibility_10m\",\n  \"dew_point_temperature_c\",\"solar_radiation_mj_m2\",\"rainfall_mm\",\"snowfall_cm\"\n)\nnum_present &lt;- intersect(num_candidates, names(train_df))\nquad_terms &lt;- if (length(num_present)) paste0(\"I(\", num_present, \"^2)\") else character(0)\n\nform3 &lt;- as.formula(paste(\n  \"rented_bike_count ~\",\n  paste(c(present_preds, int_terms, quad_terms), collapse = \" + \")\n))"
  },
  {
    "objectID": "homework8.html#cross-validation",
    "href": "homework8.html#cross-validation",
    "title": "Homework 8",
    "section": "Cross-Validation",
    "text": "Cross-Validation\nWe then want to perform a manual 10-fold CV on the training data.\n\n#define rmse function\nrmse &lt;- function(actual, pred) sqrt(mean((actual - pred)^2, na.rm = TRUE))\n\n#create folds\nmake_folds &lt;- function(n, k = 10) split(sample.int(n), cut(seq_along(sample.int(n)), k, labels = FALSE))\n\n#corss validation evaluator\ncv_eval &lt;- function(df, form, k = 10) {\n  folds &lt;- make_folds(nrow(df), k)\n  mean(sapply(folds, function(idx) {\n    d_train &lt;- df[-idx, ] %&gt;% dplyr::select(-dplyr::any_of(\"date\"))\n    d_valid &lt;- df[ idx, ] %&gt;% dplyr::select(-dplyr::any_of(\"date\"))\n    fit &lt;- lm(form, data = d_train)\n    pred &lt;- predict(fit, newdata = d_valid)\n    rmse(d_valid$rented_bike_count, pred)\n  }))\n}\n\n#define cross validations\ncv1 &lt;- cv_eval(train_df, form1)\ncv2 &lt;- cv_eval(train_df, form2)\n\nWarning in predict.lm(fit, newdata = d_valid): prediction from a rank-deficient\nfit may be misleading\n\ncv3 &lt;- cv_eval(train_df, form3)\n\nWarning in predict.lm(fit, newdata = d_valid): prediction from a rank-deficient\nfit may be misleading\n\ndata.frame(\nModel = c(\"Base\", \"Interactions\", \"Quadratic\"),\nCV_RMSE = c(cv1, cv2, cv3)\n)\n\n         Model  CV_RMSE\n1         Base 4166.220\n2 Interactions 3017.097\n3    Quadratic 2940.189"
  },
  {
    "objectID": "homework8.html#final-model-evaluation",
    "href": "homework8.html#final-model-evaluation",
    "title": "Homework 8",
    "section": "Final Model Evaluation",
    "text": "Final Model Evaluation\nWe then want to select the best model based on CV RMSE, fit it to the full training data, and evaluate on the test set.\n\nbest_form &lt;- list(form1, form2, form3)[[which.min(c(cv1, cv2, cv3))]]\n\nfinal_fit &lt;- lm(best_form, data = train_df)\ntest_pred &lt;- predict(final_fit, newdata = test_df)\ntest_rmse &lt;- rmse(test_df$rented_bike_count, test_pred)\ntest_rmse\n\n[1] 3246.43"
  },
  {
    "objectID": "homework8.html#model-coefficients",
    "href": "homework8.html#model-coefficients",
    "title": "Homework 8",
    "section": "Model Coefficients",
    "text": "Model Coefficients\nFinally, we inspect the most influential coefficients by their t-values.\n\n#grab coeff table from final model\ncoef_df &lt;- summary(final_fit)$coefficients %&gt;%\n  as.data.frame() %&gt;%\n  rownames_to_column(\"term\") %&gt;%\n  #sort by abs value on t\n  arrange(desc(abs(`t value`)))\n\n#print head example\nhead(coef_df, 20)\n\n                              term     Estimate   Std. Error    t value\n1      seasonsSummer:temperature_c -1483.206893  189.0408928 -7.8459579\n2                    seasonsSummer 38000.711260 5147.5712606  7.3822604\n3                  day_typeweekend -2392.628631  375.8600949 -6.3657426\n4      seasonsSpring:temperature_c   446.429440   88.7315214  5.0312384\n5                 I(rainfall_mm^2)     2.719790    0.6096142  4.4614942\n6                      rainfall_mm  -268.870604   60.9030564 -4.4147309\n7            solar_radiation_mj_m2 11986.775905 2772.6187359  4.3232687\n8                holidayNo Holiday  5433.324333 1433.0334416  3.7914847\n9                    temperature_c   655.385950  223.3394113  2.9344841\n10       temperature_c:rainfall_mm    -8.340725    3.0362139 -2.7470809\n11 seasonsSpring:holidayNo Holiday -4937.295925 2480.1920231 -1.9906910\n12     seasonsWinter:temperature_c  -427.224777  227.6194225 -1.8769258\n13                   seasonsSpring -5188.610420 2798.3895308 -1.8541416\n14                     (Intercept)  4195.903601 2337.8209306  1.7947926\n15      I(solar_radiation_mj_m2^2) -3600.466238 2104.5058622 -1.7108369\n16 seasonsWinter:holidayNo Holiday -2865.030872 1911.9171738 -1.4985120\n17    I(dew_point_temperature_c^2)    -4.036448    2.8883498 -1.3974927\n18                   seasonsWinter -3032.917782 2327.0555243 -1.3033285\n19                  visibility_10m     1.822709    1.9904007  0.9157497\n20 seasonsSummer:holidayNo Holiday -2031.999598 3110.5036519 -0.6532703\n       Pr(&gt;|t|)\n1  1.396151e-13\n2  2.519216e-12\n3  9.728108e-10\n4  9.529959e-07\n5  1.249463e-05\n6  1.527223e-05\n7  2.250960e-05\n8  1.893281e-04\n9  3.663630e-03\n10 6.466968e-03\n11 4.764435e-02\n12 6.173643e-02\n13 6.494063e-02\n14 7.393983e-02\n15 8.839799e-02\n16 1.353090e-01\n17 1.635506e-01\n18 1.937064e-01\n19 3.607136e-01\n20 5.142048e-01"
  },
  {
    "objectID": "homework8.html#conclusion",
    "href": "homework8.html#conclusion",
    "title": "Homework 8",
    "section": "Conclusion",
    "text": "Conclusion\nIn conclusion, we were able to identify missing data and confirm data types while also aggregating to confirm to daily data summaries. We also were able to build and compare three separate but similar regression models with cross-validation. We found the best model, with the lowest RMSE given that is the most effective method in this case to identify best mode. We also were able to explore non-linear models in this case and understand more about data science."
  }
]